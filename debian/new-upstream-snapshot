#!/bin/sh

Usage() {
   cat <<EOF
Usage: ${0##*/} trunk-dir [next-upstream-version]

   pull in new upstream snapshot from trunk-dir

   Leaves file 'new-changes.log'

   Example:
   $ ${0##*/} ../trunk
     # prepare bzr dir in . with new snapshot from ../trunk
   $ dch --edit
     # read changes in new-changes.log and write changelog
   $ debcommit
   $ dch --release
   $ debcommit --release
EOF
}
fail() { echo "$@" 1>&2; exit 1; }

print_commit() {
    local subject="$1" author="$2" bugs="$3" aname=""
    aname=${author% <*}
    echo "    - $subject${aname:+ [${aname}]}${bugs:+ (LP: ${bugs})}"
}

# unfortunately seems like no easy way to get 'Author' unless
# the committer sets it on the commit.  And since curtin is doing
# bzr merge and letting committer merge it, then author doesn't
# end up correct on most commits.
#
# log messages look like:
#revno: 424 [merge]
#fixes bug: https://launchpad.net/bugs/1618429
#committer: Ryan Harper <ryan.harper@canonical.com>
#branch nick: merge-wesley-lp1618429
#timestamp: Thu 2016-09-15 08:48:13 -0500
#message:
#  block/mdadm: add option to ignore mdadm_assemble errors
#  
#  When wiping disks with mdadm partitions we may encounter unexpected
#  return codes. In the case of wiping disks, we don't care if we 
#  observe any error so allow wipe to ignore the errors by explicitly
#  passing in ignore errors.
bzr_log_to_dch() {
    local line="" commit="" lcommit="" bugs="" bug=""
    while :; do
        read line || break
        case "$line" in
            revno:\ *)
                if [ -n "$commit" ]; then
                    print_commit "$subject" "$author" "$bugs"
                fi
                commit=${line#*: }
                bugs=""
                author=""
                subject=""
                ;;
            Author:*) author="${line#Author: }";;
            fixes\ bug:*)
                # fixes bug: https://launchpad.net/bugs/1618429
                bug="#${line##*/}"
                bugs="${bugs:+${bugs}, }${bug}";;
            message:)
                read subject;;
        esac
    done
    if [ -n "$commit" ]; then
        print_commit "$subject" "$author" "$bugs"
    fi
}

[ $# -eq 0 ] && { Usage 1>&2; exit 1; }
[ "$1" = "-h" -o "$1" = "--help" ] && { Usage; exit 0; }
trunk=$1
revno=${2:-tip}
uver=${3:-0.1.0} # the *next* upstream version

[ -d "$trunk" ] ||
   fail "trunk dir '$trunk' not a dir"
if [ "$revno" = "tip" ]; then
   revno=$(cd "$trunk" && bzr revno) ||
      fail "failed getting bzr revno from $trunk"
fi
pversion=$(dpkg-parsechangelog --show-field Version) ||
   fail "failed to read previous version with dpkg-parsechangelog"
prevno=$(echo "$pversion" | sed 's,.*bzr\([0-9]\+\)-.*,\1,') ||
   fail "fail reading previous bzr revision from previous version '$pversion'"
version=${uver}~bzr${revno}
tarball=curtin-${version}.tar.gz
t=../curtin_${version}.orig.tar.gz
if [ -f "$t" ]; then
   echo "using '$t' as tarball" 1>&2
   tarball="$t"
else
   echo "creating $tarball with bzr export" 1>&2
   bzr export --format=tgz "--revision=${revno}" "$tarball" "${trunk}" ||
     fail "failed exporting bzr in $trunk to $tarball"
fi
#bzr merge-upstream "$tarball" "--version=${version}" ||
#   fail "failed merge-upstream of $tarball at version=$version"
tmpd=$(mktemp -d "${TMPDIR:-/tmp}/curtin.${0##*/}.XXXXXX")
trap 'rm -Rf "$tmpd"' EXIT
newflist="${tmpd}/new-files"
oldflist="${tmpd}/old-files"

tar -tf "$tarball" \
   --strip-components=1 --exclude="*/debian" > "$newflist.full" ||
   fail "failed tar tf on $tarball"
sed 's,^[^/]*/,,' "$newflist.full" > "$newflist"

bzr ls --recursive --versioned > "$oldflist.full" ||
   fail "failed bzr ls --recursive"
grep -v "^debian/" "$oldflist.full" > "$oldflist"

cat "$oldflist" "$newflist" "$newflist" > "$tmpd/all-old" ||
   fail "failed getting all old files"
cat "$newflist" "$oldflist" "$oldflist" > "$tmpd/all-new" ||
   fail "failed getting all new"

removed="${tmpd}/removed"
added="$tmpd/added"
sort "$tmpd/all-old" | uniq --uniq > "$removed"
sort "$tmpd/all-new" | uniq --uniq > "$added"

while read rmfile; do
   case "$rmfile" in
      .pc/*) continue;;
      */) rflag="-r";;
      *) rflag="";;
   esac
   bzr rm $rflag "$rmfile" || fail "failed bzr rm${rflag:+ ${rflag}} $rmfile"
done < "$removed"

for f in *; do
   [ "$f" = "debian" ] && continue
   rm -rf "$f" || fail "failed removing '$f'"
done

tar --strip-components=1 --exclude "*/debian/*" -xf "$tarball" ||
   fail "failed extraction of $tarball"

while read newfile; do
    bzr add "$newfile" || fail "failed adding '$newfile'"
done < "$added"

oldrev=$(($prevno+1))
( cd "$trunk" && bzr log -r "${oldrev}..${revno}" ) > new-changes.log ||
   fail "failed to get changes from ${oldrev}..$revno"
bzr_log_to_dch < new-changes.log > new-dch.log

cat <<EOF
====
Now see ./new-changes.log for changes between $oldrev and $revno

then:
   $ dch --edit
     # read changes in new-dch.log or full changes in new-changes.log
     # and write changelog
   $ debcommit
   $ dch --release
   $ debcommit --release
   $ debuild -S
EOF

