#!/usr/bin/env python3
#   Copyright (C) 2016 Canonical Ltd.
#
#   Author: Ryan Harper <ryan.harper@canonical.com>
#
#   Curtin is free software: you can redistribute it and/or modify it under
#   the terms of the GNU Affero General Public License as published by the
#   Free Software Foundation, either version 3 of the License, or (at your
#   option) any later version.
#
#   Curtin is distributed in the hope that it will be useful, but WITHOUT ANY
#   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
#   FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
#   more details.
#
#   You should have received a copy of the GNU Affero General Public License
#   along with Curtin.  If not, see <http://www.gnu.org/licenses/>.
import argparse
import base64
import datetime
import json
import os
import sys


#  An event:
'''
{
        "description": "executing late commands",
        "event_type": "start",
        "level": "INFO",
        "name": "cmd-install/stage-late"
        "origin": "curtin",
        "timestamp": 1461164249.1590767,
},

    {
        "description": "executing late commands",
        "event_type": "finish",
        "level": "INFO",
        "name": "cmd-install/stage-late",
        "origin": "curtin",
        "result": "SUCCESS",
        "timestamp": 1461164249.1590767
    }

'''
format_key = {
    '%d': 'delta',
    '%D': 'description',
    '%e': 'event_type',
    '%l': 'level',
    '%n': 'name',
    '%o': 'origin',
    '%r': 'result',
    '%t': 'timestamp',
}

formatting_help = " ".join(["{}: {}".format(k.replace('%', '%%'), v)
                           for k, v in format_key.items()])


def format_record(msg, event):
    for i, j in format_key.items():
        if i in msg:
            msg = msg.replace(i, "{%s}" % j)
    return msg.format(**event)


def dump_event_files(event):
    content = {k: v for k, v in event.items() if k not in ['content']}
    files = content['files']
    for f in files:
        fname = f['path']
        fn_local = os.path.basename(fname)
        fcontent = base64.b64decode(f['content']).decode('ascii')
        print("wrote %s" % (fn_local))
        with open(fn_local, 'w') as fh:
            fh.write(fcontent)


def generate_records(j, blame_sort=False, print_format="%d seconds in %D",
                     dump_files=False):
    records = []
    timestamps = {}
    total_time = 0
    for event in j:
        name = event.get('name')
        if 'files' in event:
            print('Event with files: %s %s @ %s' % (event['event_type'],
                                                    event['name'],
                                                    event['timestamp']))
            if dump_files:
                dump_event_files(event)

        if event['event_type'] == 'start':
            timestamps[name] = {'start': event['timestamp']}
        else:
            timestamps[name].update({'finish': event['timestamp']})
            start = datetime.datetime.utcfromtimestamp(
                timestamps[name]['start'])
            end = datetime.datetime.utcfromtimestamp(
                timestamps[name]['finish'])
            delta = end - start
            total_time += delta.total_seconds()
            event['delta'] = "{:08.5f}".format(delta.total_seconds())
            records.append(format_record(print_format, event))

    records.append(' ---\n%3.5f seconds total time' % total_time)
    return records


def main():
    parser = argparse.ArgumentParser(
        description='curtin-print-log - pretty print and sort curtin logs',
        prog='curtin-print-log')
    parser.add_argument('--blame', action='store_true',
                        default=False,
                        dest='blame_sort',
                        help='sort events by total time.')
    parser.add_argument('--dumpfiles', action='store_true',
                        default=False,
                        dest='dump_files',
                        help='dump content of any posted files')
    parser.add_argument('--format', action='store',
                        dest='print_format',
                        default='%d seconds in %D',
                        help='specify formatting of output. ' +
                        formatting_help)
    parser.add_argument('infile', nargs='?', type=argparse.FileType('r'),
                        help='Path to log to parse. Use - for stdin')

    opts = parser.parse_args(sys.argv[1:])
    if not opts.infile:
        parser.print_help()
        sys.exit(1)

    try:
        j = json.load(opts.infile)
    except json.JSONDecodeError:
        print("Input must be valid JSON")
        sys.exit(1)

    records = generate_records(j, blame_sort=opts.blame_sort,
                               print_format=opts.print_format,
                               dump_files=opts.dump_files)
    summary = []
    if opts.blame_sort is True:
        summary = records[-1:]
        records = sorted(records[:-1], reverse=True)

    print("\n".join(records + summary))


if __name__ == '__main__':
    main()
